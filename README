Specification of the data object
--------------------------------

The book data object should provide certain required methods.

Methods:

* getComponents: returns an array of all the component ids that are to be
    accessed in linear reading order (ie, like the spine in an EPUB OPF file --
    you don't have to list every component, just the ones that are read in
    order).

* getContents: a function that returns an array of nested objects. Each object
    responds to `title` (a string), and `src`. `src` is a string that
    "addresses" a component and (optionally) a location within that component.
    Locations within components are indicated using standard HTML anchor
    notation â€” for example, "cmpt1#part3" points to an element with an id
    of "part3" within the component named "cmpt1".

    This is an example of a contents structure with one top-level section
    containing two sub-sections:

    [
      {
        title: "I: A curious incident",
        src: "component1.xhtml",
        children: [
          {
            title: "I. a. Part the first",
            src: 'component1.xhtml#part-the-first'
          },
          {
            title: "I. a. Part the second",
            src: 'component3.xhtml#part-the-second'
           }
         ]
       }
    ]

* getComponent(componentId): takes a component id (from the list returned
    by this.getComponents) and returns the body text of the corresponding
    component.
    Q: should it also return the stylesheet rules?

* getMetaData(key): takes a string "key" and returns the value of that
    metadata for this book. There is not yet any standardised list of
    possible keys -- we'll just see what happens for a bit. Note that if
    nothing will go wrong if you return null or an empty string for any
    requested key.

Note that if these methods retrieve any data from a server using AJAX
techniques, it should be a synchronous operation, because the clients of the
book data object expect the result to be returned from the method itself
(not via a callback).


Example use
-----------

  var bookData = {
    getComponents: function () {
      return [
        'component1.xhtml',
        'component2.xhtml',
        'component3.xhtml',
        'component4.xhtml'
      ];
    },
    getContents: function () {
      return [
        {
          title: "Chapter 1",
          src: "component1.xhtml"
        },
        {
          title: "Chapter 2",
          src: "component3.xhtml#chapter-2"
        }
      ]
    },
    getComponent: function (componentId) {
      return {
        'component1.xhtml':
          '<h1>Chapter 1</h1><p>Hello world</p>',
        'component2.xhtml':
          '<p>Chapter 1 continued.</p>',
        'component3.xhtml':
          '<p>Chapter 1 continued again.</p>' +
          '<h1 id="chapter-2">Chapter 2</h1>' +
          '<p>Hello from the second chapter.</p>',
        'component4.xhtml':
          '<p>THE END.</p>'
      ][componentId];
    },
    getMetaData: function(key) {
      return {
        title: "A book",
        creator: "Inventive Labs"
      }[key];
    }
  }

  // Initialize the reader element.
  var reader = Carlyle.Reader('reader');

  // Initialize a book object.
  var book = Carlyle.Book(bookData);

  // Assign the book to the reader and go to the 14th page.
  reader.setBook(book);
  reader.moveToPage(14);


Reader Events
-------------

Events marked with (c) are cancellable -- call preventDefault() on them if
you need to.

* carlyle:initializing (NB: too early to call addControl)
* carlyle:loading
* carlyle:loaded
* carlyle:resizing (c)
* carlyle:resized
* carlyle:bookchanging (c)
* carlyle:bookchange
* carlyle:pagechanging (c)
* carlyle:pagechange
-* carlyle:flipperchanging (c)
-* carlyle:flipperchange
* carlyle:lift:forward (c)
* carlyle:lift:backward (c)
* carlyle:lift:unhandled
-* carlyle:drop:forward (c)
-* carlyle:drop:backward (c)
-* carlyle:drop:unhandled
* carlyle:turn


Adding controls
---------------

!TODO!


Alternative page flipping mechanisms
------------------------------------

!TODO!


Javascript Object Style
-----------------------

In this incarnation at least, Carlyle uses a Javascript idiom for defining
many of the core classes. This is designed to declutter the classes, clarify
their API, and reduce dependency problems that would constrain the progress of
the project at this early style.

Essentially, the constructor function returns not the instance itself, but
an object that references the public methods and properties of that object.

The class idiom looks like this:

  Carlyle.Foo = function (args) {
    // Allows the constructor function to be an object factory itself,
    // ie: "Carlyle.Foo()" is the same as "new Carlyle.Foo()".
    if (Carlyle == this) { return new Carlyle.Foo(args); }

    // Conventional name for any class constants.
    var k = {
      AConstant: 'Foo',
      PI: 3.14
    };

    // Conventional name for any publicly accessible properties (instance
    // variables).
    var p = {
      someVariable: 'bar'
    };

    // Conventional name for the object that is returned by the constructor,
    // allowing access to the public methods and properties by external
    // code.
    var API = {
      constructor: Carlyle.Foo,
      properties: p,
      constants: k
    };


    // A method that will be exposed via the API.
    function examplePublicMethod() {
    }


    // A method that is only available to code within the constructor itself.
    function exampleInternalMethod() {
    }

    // Typically, public methods are attached to the API just before returning,
    // for easier scannability of the API.
    API.examplePublicMethod = examplePublicMethod;

    return API;
  }

This allows a quite concise, clear coding style. However, it does make class
inheritance somewhat limited. There is room for the idiom to be reviewed if
it proves to be a significant constraint on projects using Carlyle.
